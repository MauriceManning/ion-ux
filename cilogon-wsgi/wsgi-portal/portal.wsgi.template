import os, sys
os.environ['PORTAL_ROOT'] = '/www/ux/cilogon-wsgi/'
os.environ['PATH_INFO'] = '/wsgiportal'
sys.path.insert(0, os.environ['PORTAL_ROOT'] + 'wsgi-portal')
sys.path.insert(0, os.environ['PORTAL_ROOT'] + 'cilogon')

__author__ = 'jeff gaynor'

import time
import re, hashlib, random
import logging
import cgi
from oa4mp import OA4MPService, Config, FileStore
from  urllib import unquote
from string import strip
from flask import Flask, request

import base64
CERT_REQUEST_ID="oa4mp_client_req_id" # As per spec.
CONFIG_FILE_KEY = "oa4mp.config.file"
CONFIG_NAME_KEY="oa4mp.config.name"

flask_url_base='http://FLASK_HOST_VALUE'

def index(environ, start_response):
    action = environ['oa4mp.config.path'] + '/startRequest'
    logit(environ, "landed on index page.")
    start_response('200 OK', [('Content-Type', 'text/html')])
    body = '<html><body><H1>A Sample Delegation Portal</h1>'
    body = body + '<form name="input" action="' + action + '" method="get" enctype="application/x-www-form-urlencoded">'
    body = body + 'Click to request a credential<br><br><input type="submit" value="start request" /></form>'
    body = body + '<br> ' + environ[CONFIG_FILE_KEY]
    body = body + '</body></html>'
    return body


def not_found(environ, start_response):
    """Called if no URL matches."""
    logit(environ, "NOT FOUND -- request for a non-existent endpoint returns a 404 error")
    redirecturl = flask_url_base + '/?login_request_for_non_existent_endpoint'
    headers = [('Content-Type', 'text/html'), ('Location', redirecturl)]
    start_response('302 FOUND', headers)
    return "<html><body>Please follow this <a href=\""+ redirecturl +"\">link</a>!</body></html>\n"

def failure(environ, start_response):
    """
    Called in case of failures and also given as a redirect from the server if the user, say, cancels and
    operation.
    """
    redirecturl = flask_url_base + '/?cancel'
    headers = [('Content-Type', 'text/html'), ('Location', redirecturl)]
    start_response('302 FOUND', headers)
    #start_response('200 OK', [('Content-Type', 'text/html')])
    return "<html><body>Please follow this <a href=\""+ redirecturl +"\">link</a>!</body></html>\n"


# Wrapper that has causes asset store cleanup after each callback.
# This is not optimal, but probably the easiest way to get
# WSGI to actually do something like this.

def callback(environ, start_response):
     try:
        return _callback(environ, start_response)
     finally:
        configFile = environ[CONFIG_FILE_KEY]
        configName = environ[CONFIG_NAME_KEY]
        config = Config(configFile, configName)
        cfg = config.read()
        store = FileStore(cfg=cfg)
        # Perform required cleanup task. Given the difficulty of controlling threads
        # in WSGI having an invocation at the end of the call back is an acceptable trade-off
        # This might have to be improved later...
        store.cleanup()


def _callback(environ, start_response):
    """
    The callback, to wit, this will take the oauth token returned by the server, swap it for an
     access token then get the cert, storing it as an asset.
    """
    # Standard canonical way to interpret the request values is to run the wsgi environment
    # through the cgi module
    form = cgi.FieldStorage(fp=environ['wsgi.input'],
                            environ=environ,
                            keep_blank_values=1)

    # Get data from fields
    token = unquote(form.getvalue('oauth_token', None))
    v  = unquote(form.getvalue('oauth_verifier', None))
    configFile = environ[CONFIG_FILE_KEY]
    configName = environ[CONFIG_NAME_KEY]
    logging.info('using cfg file=' + environ['oa4mp.config.file'] + ', name=' + environ['oa4mp.config.name'])

    config = Config(configFile, configName)
    cfg = config.read()
    logit(environ, "skin=" + cfg["skin"])
    id = None
    if environ.has_key('HTTP_COOKIE'):
        for cookie in map(strip, re.split(';', environ['HTTP_COOKIE'])):
            try:
                (key, value ) = re.split('=', cookie)
                if key == CERT_REQUEST_ID:
                    id = value
                    # jump out once you find the first one. If they have cruft in their browser
                    # such as from repeated failed earlier attempts, we can't figure which is the right one
                    break

            except ValueError, e:
                logging.exception('Benign error parsing cookie=' + cookie + '. Skipping...')

    # In this case, no cookie was found to identify that a request was made.
    if id is None:
        start_response('404 NOT FOUND', [('Content-Type', 'text/html')])
        body = '<html><body><h2>Error, no session cookie found</h2></body></html>'
        return body
    logit(environ, "in callback for id=" + id)

    oa4mp = OA4MPService()
    username, cert = oa4mp.getCert(id, cfg, token, v)
    action = environ['oa4mp.config.path']

    cert = base64.b64encode(cert)
    redirecturl = flask_url_base + '/signon?cert=' + cert
    headers = [('Content-Type', 'text/html'), ('Location', redirecturl)]
    start_response('302 FOUND', headers)
    return "<html><body>Please follow this <a href=\""+ redirecturl +"\">link</a>!</body></html>\n"



def startRequest(environ, start_response):
    """
    Start the cert request cycle. This will create a random that is set in a cookie
    which will be later read so that the state can be managed (state meaning an
    asset in the asset store). If successful, this returns a redirect to the main
    site.
    """
    # get the name from the url if it was specified there.
    #print >> environ['wsgi.errors'], "cfg file = " + environ['oa4mp.config.file']
    logit(environ, "starting new request")

    oa4mp = OA4MPService()
    configFile = environ['oa4mp.config.file']
    configName = environ['oa4mp.config.name']

    config = Config(configFile, configName)
    cfg = config.read()
    # print >> environ['wsgi.errors'], "service uri = " + cfg['serviceUri']
    id = 'oa4mp-' + hashlib.sha1(str(random.random()) + str(random.random())).hexdigest()
    logit(environ, "created id = " + id)
    key, redirectUri = oa4mp.requestCert(id, cfg)
    headers = [('Content-Type', 'text/html'),
       ('Set-Cookie', CERT_REQUEST_ID + '=' + id + ";"),# cookie -- don't set path since API for reading doesn't support it!!!
       ('Location', redirectUri)]# Location header + 302 status code = redirect
    logit(environ, "set cookie");#    foo = [('Content-Type', 'text/html'),
    # Status of 302 required for redirect.
    start_response('302 FOUND', headers)

    # If the 302 redirect works as it should, then the body will never be seen. In case something happens
    # the user should at least have a chance to continue manually.
    body=  '<html><body>Please follow this <a href="'
    body = body + str(redirectUri) #or the body is converted to unicode and cannot be used as a response.
    body = body + '">link</a>!</body></html>\n'
    logit(environ, "done with initial request, redirect uri = " + str(redirectUri))
    return body

# Primitive logging, but works across the board. Replace if you need something more clever.
# Everything goes to the error file so designated by your setup.
def logit(environ, x):
    print >> environ['wsgi.errors'], str(x)


def success(environ, start_response):
    """
    Very primitive success page.
    """
    logit(environ, "Success page requested")
    return "<html><body><h2>Success!!!</h2></body></html>"

urls = [
    (r"startRequest", startRequest),
    (r"success", success),
    (r"failed", failure),
    (r"index", index),
    (r"ready", callback),
    ##(r"^$", index),
    (r"^$", startRequest),

]




def application(environ, start_response):
    """
    The main WSGI application. Dispatch the current request to
    the functions from above and store the regular expression
    captures in the WSGI environment.

    If nothing matches call the `not_found` function.
    """
    #Note: PATH_INFO is a standard WSGI environment value for the path in the request URL.
    # If running in the debugger, uncomment these three lines to fake an Apache server.
    # FIXME!!
    #environ[CONFIG_FILE_KEY]='/home/ncsa/dev/csd/config/oa4mp-clients.xml'
    #environ[CONFIG_NAME_KEY]='python-cilogon2'
    #environ['oa4mp.config.path']='client'
    path = environ.get('PATH_INFO', '').lstrip('/')
    for regex, callback in urls:
        match = re.search(regex, path)
        if match is not None:
            environ['myapp.url_args'] = match.groups()
            return callback(environ, start_response)
    return not_found(environ, start_response)

# Simple entry point for running a debug server. Generally only for development since
# any OA4MP server will refuse to connect to this without SSL.
if __name__ == '__main__':
    from wsgiref.simple_server import make_server
    srv = make_server('localhost', 44443, application)
    srv.serve_forever()
